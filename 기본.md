# 기본

[object Object] 를 볼때 

JSON.stringify()를 사용하면 볼수는 있다.

한 태그에 여러개 

```typescript
@click="[method1(), method2()]"


@click="기조꺼() , 기존꺼2()" # 이런식으로 () 붙여줘야 되드라
```

## 외부클릭

```typescript
<tag> v-click-outside="onClickOutside" </tag>
```

[Vuetify — A Material Design Framework for Vue.js](https://vuetifyjs.com/en/directives/click-outside/#usage)

## v-if 와 vi-show 차이점

공통점으로 둘다 동일한 기능으로 숨기거나 보여준다

차이점

- v-if 는 실제 DOM에 그려주지 않는 방법이고 

- v-show는  display:none속성을 해주는거

`v-if`와 `v-for`는 동시 사용을 권장하지 않음 동일한 노드(태그)에 두가지 모두 있다면 `v-for`가 `v-if`보다 높은 우선순위를 갖는다 `v-if`는 루프가 반복도리 때마다 실행됩니다. 이는 일부 항목만 렌더링 하려는 경우 유용합니다.

## v-for  ?

리스트 렌더링 

기존 정리는 그냥 이거 참조

[리스트 렌더링 — Vue.js](https://kr.vuejs.org/v2/guide/list.html)

:key?  -> 2,20에서 부터는 필수라고 써있다

vue가 각노드의 id를 추적하고, 기존 엘리먼트를 재사용 재정렬할 수 있도록 각 항목에 고유한 key를 정의  가능하면 유니크,유일값으로 

# data()

```typescript
data:function(){

    return{
        공유할변
    }
}
```

data선언 변순느 페이지 공유? setup()은 안되던데

# MQTT

```terminal
mosquitto_sub -h ip(127.0.0.1) -t Topic   # 예제? 실행
```

# 컴포넌트간 통신  혹은 $emit 를 보기에 가장 괜찮음

```
https://pinedance.github.io/blog/2020/09/24/data-and-event-between-vue-components
```

view 는 페이지지 컴포넌트가 아니라 $emit를 받지않나?  받음 

# composition api 참고

```
https://kyounghwan01.github.io/blog/Vue/vue3/composition-api/#setup
```

# Vue lifecycle

```
https://velog.io/@yeyo0x0/Vue.js-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4-%ED%9B%85
```

- updated()부분보다 methods부분이 먼저 실행됨

- mounted()는 methods보다 먼저 실행 

```
대략 순서 mounted() => methods() => beforeupdate() -> update()
```

# Vue의 setup()

> 엘리먼트에 함수 리턴하면 계속 재실행해서 못써먹음

인자로는 `props` 와 `context`를 받는다 이때 props는 같은 파일에 선언된 props인거 같음

하지만 props는 반응형이기 때문에 setup 펑션의 `toRefs`를 사용한다. => 반응형 객체 접근해서 고정값으로 가져오는거 같음..

`Context`는 3가지 키값을 가진 딕셔너리를 말하는거 같음 원본은 3가지 컴포넌트 프로퍼티를 가지만 일반 js객체 

`setup()`은 실행시 컴포넌트 인스턴트는 생성 전임 => 그래서 화면 로딩시 한번 log가 나왔나 싶음

`setup`이 실행될 때, 컴포넌트 인스턴스는 아직 생성되지 않았습니다. 결과적으로 아래와 같은 속성에만 접근할 수 있습니다:

- `props`
- `attrs`
- `slots`
- `emit`

즉, 다음 컴포넌트 옵션에는 **접근할 수 없습니다**:

- `data`
- `computed`
- `methods`

코드보면 return 에서는 `computed`를 사용한다. 

`setup()`에서의 `this`는 다른 옵션 내부의 this와 다르게 동작함

다른 예시는 찾아보고

내 생각에는 (구)거제.ver는 지금과는 다르게 device-cp에다가 실행,정지 버튼을 만들어놨고 그곳에서 run()를 실행시킨다 물론 가져오는 거는 import는 아니지만 setup()에서 `composable`의 `common` 폴더의 `index.ts`에 있는 것을 사용하는듯 지금 집에서는 공유기인가 방화벽 때문인가 안됨 

어떻게든 함수 가져와서 run()함수 실행 commandDevice에 적당한 값을 찾아서 넣어주기만 하면된다. 무리없이 똑같은걸 가져올수만 있다면 성공인듯한ㄷ

문제는 import가 아니라 setup()으로 가져왔는데 이게 왜 되는건지 모르겠음 

# computed 와 watch

## computed

- Computed 주로 속성을 줄이거나 복잡한 템플릿을 간소화 하기위해 사용함

- computed 속성 대신에 메서드와 동일한 함수를 정의할 수 있다

-  **computed 속성은 반응형(reactive) 종속성에 기반하여 캐시된다는 것** 입니다

- 깨알 추가로 methods는 다시 렌더링 될때마다 **항상** 호출됨

## watch

- 대부분의 경우 computed가 더 적절함, 사용자 지정 감시자(watch)가 필요한 경우 

- 비동기 혹은 비용이 많이드는 경우 사용

---

# Type 'string[]' cannot be used as an index type. 에러

```typescript
type ObjType = {
    [index: string]: boolean
}
const lst = ['ex1','ex2','ex3']
let dic:ObjType = {}
for(let i = 0;i< lst.length;i++){
    dic[lst[i]] = false
}


ㅇ에러난 부분을 ObjType 로 재정의 하여 에러는 넘김 
```

# 페이지 이동시 데이터 보내기 $route.push

```typescript
@click="$router.push({name:'test1',params:{'status1':'true','status2':'false','status3'


created(){
        // console.log(this.$route.params)
        // console.log(this.$route.params.status1)
        if(this.$route.params.status1 == 'true'){
            this.tabItem[0].inClass = true
            this.process1 = true
        }
    }
화화면 로딩시 해줘야 해서 created() 사
```

# CSS 코드 작성규칙

## 기본 규칙

- 모든 속성은 숫자, 대문자, 특수문자로 시작할 수 없으며, 영문 소문자로 작성합니다.
- 단어의 구분을 위하여 하이픈 표기법을 사용합니다.
- 마지막 속성 값의 끝에도 세미콜론을 사용합니다.
- 방향에 따라 속성을 지정해야 하는 경위 top, right, bottom, left 순으로 작성합니다.

## 선택자 구분

스타일 엔진은 다음 4개의 카테고리로 스타일 규칙을 분류합니다.

1. ID 규칙
2. Class 규칙
3. Tag 규칙
4. Universal 규칙

이 4개의 규칙들은 스타일 규칙을 적용하는데 기본적인 역할을 하므로 이해하는 것이 중요합니다.

**키 선택자**

선택자의 마지막 선택자를 의미합니다**.** 아래 코드에서 키 선택자는 img, p, [title]이 됩니다. 따라 마지막 작성된 키 선택을 기준으로 규칙을 분류할 수 있습니다.

```
a img, div > p, h1 + [title] {...}
```

**ID 규칙**

```
button#backButton {…} /* 이건 ID 규칙이다. */
#urlBar[type="autocomplete"] {…} /* 이것도 ID 규칙이다. */
treeitem > treerow > treecell#myCell:active {…} /* 이것도 ID 규칙이다. */
```

**Class 규칙**

```
button.toolbarButton {…} /* Class 규칙 */
.fancyText {…}    /* Class 규칙 */
menuitem > .menu-left[checked="true"] {…} /* Class 규칙 */
```

**Tag 규칙**

```
td {…} /* Tag 규칙 */
treeitem > treerow {…} /* Tag 규칙 */
input[type="checkbox"] {…} /* Tag 규칙 */
```

**Universal 규칙**

```
[hidden="true"] {…} /* universal 규칙 */  
* {…}        /* universal 규칙 */
tree > [collapsed="true"] {…} /* universal 규칙 */
```

# JS  카멜 케이스

## 변수, 함수명은 카멜 케이스를 사용한다.

첫글자는 소문자, 단위로 첫글자 대문자를 사용, 중간에 언더바(_)사용 금지한다. 대표적인 표기법으로 카멜 케이스, 파스칼 표기법, 헝가리안 표기법, 스네이크 표기법이 있으며 사용하는 언어에 따라 권장사항이 다르다.

```javascript
var pageName;
```

## 상수는 영문 대문자 스네이크 표기법을 사용한다.

```javascript
var SYMBOLIC_NAME;
```

여러 단어가 합쳐져 만들어진 약어(HTML, XML)의 경우는 전부 대문자로 사용한다.

```javascript
var HTML;
```

## 생성자 함수는 대문자 카멜 케이스를 사용한다.

```javascript
function Func() {
    ...
}
```

## 지역변수 혹은 private 변수는 언더바(_)로 시작한다.

```javascript
var _private;
```

## 예약어를 사용하지 않는다.

```javascript
// bad
var if;
var for;
var this;
...
```

## 전역 변수를 사용하지 않는다.

모든 컴파일 단위는 하나의 공용 전역 객체(window)에 로딩된다. 전역 변수는 언제든지 프로그램의 모든 부분에서 접근할 수 있기 때문에 편하지만, 바꿔 말하면 프로그램의 모든 부분에서 변경될 수 있고, 그로 인해 프로그램에 치명적인 오류를 발생시킬 수 있다.

```javascript
var global = 'data';
```

## 암묵적 전역 변수를 사용하지 않는다.

```javascript
// bad
function sum(x, y) {
  result = x + y;
  return result;
}

// bad
function foo() {
  var a = b = 0; // var a = (b = 0);와 같다. b가 암묵적 전역이 된다.
}

// good
function sum(x, y) {
  var result = x + y;
  return result;
}

// good
function foo() {
  var a, b;
  a = b = 0;
}
```
